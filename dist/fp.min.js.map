{"version":3,"file":"fp.min.js","sources":["../package.json","../src/utils/object/has-own-property.js","../src/utils/object/assign.js","../src/utils/object/is.js","../src/utils/object/get-prototype.js","../src/utils/object/_equals.js","../../../../../../src/utils/_symbols.js","../src/utils/doc.js","../src/utils/trace.js","../src/utils/path.js","../src/utils/map.js","../src/utils/optims/apply.js","../src/utils/optims/arrayConcat.js","../src/utils/optims/getLength.js","../src/utils/optims/setArity.js","../src/utils/optims/toArray.js","../src/partial.js","../src/curry.js","../src/compose.js","../src/arity.js","../src/not.js","../src/functions/noop.js","../src/functions/identity.js","../src/functions/constant.js","../../../../../../src/functions/index.js","../src/collection.js","../src/index.js"],"sourcesContent":["{\n  \"name\": \"fp\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Readable, debbuggable & fast ES6 Functional Programming\",\n  \"author\": \"Adrien Gibrat <adrien.gibrat@gmail.com>\",\n  \"license\": \"MIT\",\n  \"main\": \"fp.js\",\n  \"jsnext:main\": \"src/index.js\",\n  \"engines\": {\n    \"npm\": \">= 2.0.0\"\n  },\n  \"eslintConfig\": {\n    \"env\": {\n      \"browser\": true,\n      \"es6\": true\n    },\n    \"parserOptions\": {\n      \"ecmaVersion\": 6,\n      \"sourceType\": \"module\"\n    }\n  },\n  \"scripts\": {\n    \"start\": \"npm run watch\",\n    \"bench\": \"npm run bench:curry && npm run bench:collection\",\n    \"bench:curry\": \"node bench/curry.bench.js\",\n    \"bench:collection\": \"node bench/collection.bench.js\",\n    \"build\": \"npm run build:core && npm run build:core:min && npm run build:monads && npm run build:monads:min\",\n    \"build:core\": \"rollup --config --id fp --input src/index.js --output dist/fp.js\",\n    \"build:core:min\": \"rollup --config --environment BUILD:min --id fp --input src/index.js --output dist/fp.min.js\",\n    \"build:monads\": \"rollup --config --id fp.monads --globals fp:fp --input src/index.monads.js --output dist/fp.monads.js\",\n    \"build:monads:min\": \"rollup --config --environment BUILD:min --id fp.monads --globals fp:fp --input src/index.monads.js --output dist/fp.monads.min.js\",\n    \"check\": \"check-dependencies --verbose\",\n    \"perf\": \"npm run perf:init && npm run perf:collection\",\n    \"perf:init\": \"grep 1 /proc/sys/kernel/kptr_restrict > /dev/null && sudo sh -c 'echo 0 > /proc/sys/kernel/kptr_restrict && echo 1 > /proc/sys/kernel/perf_event_paranoid' || echo 'perf init already done'\",\n    \"perf:collection:record\": \"perf record -i -g -q -e cycles:u -- node --perf-basic-prof src/collection.bench.js && npm run perf:script\",\n    \"perf:script\": \"LANG=C perf script | egrep -v ' __libc_start| LazyCompile | v8::internal::| Builtin:| Stub:| LoadIC:|\\\\[unknown\\\\]| LoadPolymorphicIC:' | stackcollapse-perf 2>/dev/null | grep runbench | sed 's/LazyCompile:[*~]\\\\?//g;s/node`//g;s|'$PWD'/||g;s/^.*runbench//' > perf/script.collapsed.txt\",\n    \"perf:collection:flamegraph\": \"stackvis collapsed < perf/script.collapsed.txt > perf/collection.flamegraph.html\",\n    \"perf:collection\": \"npm run perf:collection:record && npm run perf:collection:flamegraph\",\n    \"size\": \"npm run size:core --silent && npm run size:core:min --silent && npm run size:monads --silent && npm run size:monads:min --silent\",\n    \"size:core\": \"echo \\\"fp raw size `cat dist/fp.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:core:min\": \"echo \\\"fp minified & gzipped `gzip -9 -c dist/fp.min.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:monads\": \"echo \\\"fp.monads raw size `cat dist/fp.monads.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:monads:min\": \"echo \\\"fp.monads minified & gzipped `gzip -9 -c dist/fp.monads.min.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"test\": \"npm run test:partial && npm run test:curry && npm run test:compose\",\n    \"test:partial\": \"node test/partial.test.js\",\n    \"test:curry\": \"node test/curry.test.js\",\n    \"test:compose\": \"node test/compose.test.js\",\n    \"watch\": \"chokidar 'src/**/*.js' --command 'time npm run build:core --silent && echo \\\"build core done\\\" && time npm run build:monads --silent && echo \\\"build monads done\\\"'\",\n    \"watch:core\": \"chokidar 'src/**/*.js' --command 'time npm run build:core --silent && echo \\\"build core done\\\"'\",\n    \"watch:monads\": \"chokidar 'src/**/*.js' --command 'time npm run build:monads --silent && echo \\\"build monads done\\\"'\"\n  },\n  \"devDependencies\": {\n    \"check-dependencies\": \"^0.12.0\",\n    \"chokidar-cli\": \"^1.2.0\",\n    \"rollup\": \"^0.26.1\",\n    \"rollup-plugin-buble\": \"^0.6.0\",\n    \"rollup-plugin-eslint\": \"^2.0.0\",\n    \"rollup-plugin-includepaths\": \"^0.1.2\",\n    \"rollup-plugin-json\": \"^2.0.0\",\n    \"rollup-plugin-uglify\": \"^0.3.1\",\n    \"tape\": \"^4.5.1\"\n  },\n  \"optionalDependencies\": {\n    \"benchmark\": \"^2.1.0\",\n    \"flamegraph\": \"^0.7.0\",\n    \"lazy.js\": \"^0.4.2\",\n    \"lodash\": \"^4.11.2\",\n    \"ramda\": \"^0.19.1\",\n    \"stackvis\": \"^0.3.0\",\n    \"transducers-js\": \"^0.4.174\",\n    \"transducers.js\": \"^0.3.2\"\n  }\n}\n","/* global Object: false, Function: false */\n\nexport default Function.call.bind(Object.prototype.hasOwnProperty)\n","import hasOwnProperty from 'utils/object/has-own-property'\n\n/* global Object: false */\n\nexport default Object.assign || function assign (target) {\n\tfor (let index = 1; index < arguments.length; index++) {\n\t\tlet source = arguments[index]\n\t\tif (source != null)\n\t\t\tfor (let key in source)\n\t\t\t\tif (hasOwnProperty(source, key))\n\t\t\t\t\ttarget[key] = source[key]\n\t}\n\treturn target\n}\n","/* global Object: false */\n\nexport default Object.is || function is (a, b) {\n\treturn a === b ?\n\t\t//+0 !== -0\n\t\ta !== 0 || 1 / a === 1 / b :\n\t\t// NaN === NaN\n\t\ta !== a && b !== b\n}\n","/* global Object: false */\n\nexport default Object.getPrototypeOf\n","import is from 'utils/object/is'\nimport getPrototype from 'utils/object/get-prototype'\n\n/* global Object: false, Array: false */\n\nfunction getProperties (object) {\n\tconst properties = []\n\tfor (; object != null; object = getPrototype(object))\n\t\tArray.prototype.push.apply(\n\t\t\tproperties,\n\t\t\tObject.getOwnPropertyNames(object).concat(Object.getOwnPropertySymbols(object))\n\t\t\t\t.filter((property) => properties.indexOf(property) === -1)\n\t\t)\n\treturn properties\n}\n\nexport default function equals (a, b) {\n\tconst aType = typeof a\n\tif (aType !== typeof b)\n\t\treturn false\n\tif (is(a, b))\n\t\treturn true\n\tif (aType !== 'object')\n\t\treturn false\n\tconst aProperties = getProperties(a)\n\tconst bProperties = getProperties(b)\n\tconst aValue = typeof a.valueOf === 'function' && a.valueOf()\n\tconst bValue = typeof b.valueOf === 'function' && b.valueOf()\n\tconst aContainValue = aValue !== a\n\tconst bContainValue = bValue !== b\n\n\treturn aProperties.length === bProperties.length\n\t\t&& aProperties.every((key) => equals(a[key], b[key]))\n\t\t&& (aContainValue && bContainValue ? equals(aValue, bValue) : true)\n}\n","export const signature = Symbol('signature')\nexport const targetFn = Symbol('targetFn')\nexport const boundThis = Symbol('boundThis')\nexport const partialArgs = Symbol('partialArgs')\nexport const placeholder = Symbol('placeholder')\n","import {signature} from 'symbols'\n\ndoc[signature] = 'doc :: (* → *) → String'\n\n/* global Object: false */\n\nexport default function doc (fn) {\n\treturn `doc ${fn && (fn[signature] || fn.name) || Object.prototype.toString.call(fn)}`\n}\n\n/*\n// SEE http://www.cjandia.com/2012/06/x-calc/dhm/lib/?types.js\nconst _funcNamePattern = /^([^:\\s]+)\\s*::\\s+/\nconst _separatorPattern = /\\s*→\\s+/\nconst _namePattern = /\\s+([a-zA-Z0-9]+)\\s+/ // *Definition* Name\n//const _typePattern = /\\s*[a-z\\d]+\\s*$/i // Type *Definition*\nconst _argumentsPattern = /\\s*,\\s+/\nconst _optionalPattern = /^\\?\\s*([^\\s])(?:\\s*([^=]))?(?:\\s*=\\s*(.*))?/ // ?*Type* *Name* = *Default*\nconst _listPattern = /\\[([^\\]])\\]/ // [*Definition*]\nfunction _parseArgs (signature) {\n\tlet deepParenthesis = 0\n\tlet deepList = 0\n\tlet offset = 0\n\n\tsignature.arguments = [].reduce.call(signature.source, function parser (args, char, index, string) {\n\t\tconst openParenthesis = char === '('\n\t\tconst closeParenthesis = char === ')'\n\t\tconst openList = char === '['\n\t\tconst closeList = char === ']'\n\t\tconst separator = char === '→' || char === ','\n\t\t// const optional = char === '?'\n\t\t// const defaultValue = char === '='\n\t\tconst end = index === string.length - 1\n\n\t\tconst source = string.slice(offset ? offset : offset + 1, index)\n\t\tlet parsed = []\n\n\t\tcloseParenthesis && deepParenthesis--\n\t\tcloseList && deepList--\n\n\t\tif (closeParenthesis && !deepParenthesis) { // parenthesis group\n\t\t\tparsed = _parseArgs({source})\n\n\t\t\tconst named = string.slice(index + 1).match(_namePattern)\n\t\t\tif (named) {\n\t\t\t\tindex += named[0].length\n\t\t\t\tparsed.name = named[1]\n\t\t\t}\n\n\t\t\tparsed.source = string.slice(offset ? offset - 1 : offset, index + 1).trim()\n\n\t\t\toffset = index + 1\n\t\t} else if (closeList && !deepList) { // list\n\t\t\tparsed = _parseArgs({source})\n\n\t\t\tparsed.type = 'List'\n\t\t\tparsed.of = source\n\t\t\tparsed.source = string.slice(offset ? offset - 1 : offset, index + 1)\n\n\t\t\toffset = index + 1\n\t\t} else if (!deepParenthesis && !deepList && separator || end) { // flat signature\n\t\t\tparsed = [string\n\t\t\t\t.slice(offset, index).trim()]\n\t\t\t\t//.split(_separatorPattern)\n\t\t\t\t//.reduce((args, arg) => args\n\t\t\t\t//\t.concat(arg.split(_argumentsPattern).filter(Boolean))\n\t\t\t\t//, [])\n\t\t\t\t.map((string)=> ({ source: string }))\n\t\t\t\t// .map((item) => { // handle list type\n\t\t\t\t// \tconst list = item.source.match(_listPattern)\n\t\t\t\t// \tif (list) {\n\t\t\t\t// \t\titem.type = 'List'\n\t\t\t\t// \t\titem.of = list[1]\n\t\t\t\t// \t}\n\t\t\t\t// \treturn item\n\t\t\t\t// })\n\t\t\t\t.map((item) => { // handle optional params\n\t\t\t\t\tconst optional = item.source.match(_optionalPattern)\n\t\t\t\t\tif (optional) {\n\t\t\t\t\t\titem.optional = true\n\t\t\t\t\t\titem.type = optional[2] && optional[1]\n\t\t\t\t\t\titem.name = optional[2] || optional[1]\n\t\t\t\t\t\titem.default = optional[3]\n\t\t\t\t\t}\n\t\t\t\t\treturn item\n\t\t\t\t})\n\t\t\t\t.map((item) => { // guess name & type\n\t\t\t\t\tif (!item.name)\n\t\t\t\t\t\titem.name = item.source\n\t\t\t\t\tif (!item.type && item.name.length > 2) {\n\t\t\t\t\t\titem.type = item.name\n\t\t\t\t\t\tdelete item.name\n\t\t\t\t\t}\n\t\t\t\t\treturn item\n\t\t\t\t})\n\n\t\t\toffset = index + 1\n\t\t}\n\n\t\topenParenthesis && deepParenthesis++\n\t\topenList && deepList++\n\n\t\treturn args.concat(parsed)\n\t}, [])\n\t\t.filter(Boolean)\n\n\tif (signature.arguments.length > 1) {\n\t\tsignature.type = 'Function'\n\t\tsignature.return = signature.arguments.pop()\n\t\tsignature.arity = signature.arguments.find((arg) => arg.source === '…') ?\n\t\t\t'variadic' :\n\t\t\tsignature.arguments.filter((arg) => !arg.optional).length\n\t}\n\n\treturn signature\n}\n\n\ndoc._parse = (fn) => {\n\tlet name\n\tconst _signature = fn && fn[signature]\n\tconst parsed = _signature && _parseArgs({\n\t\tsource: _signature.replace(_funcNamePattern, (_, _name) => (name = _name, ''))\n\t})\n\tparsed && (parsed.name = name)\n\treturn parsed\n}\n//*/\n","import {signature} from 'symbols'\n\ntrace[signature] = 'trace :: String → α → α'\n\n/* global console: false */\n\nexport default function trace (tag, value) {\n\tconsole.log(`${tag} %1$O\\n%1$s`, value)\n\treturn value\n}\n","/* global String: false */\n\nexport default function path (path, object) {\n\tif(!Array.isArray(path))\n\t\tpath = String.prototype.split.call(path, '.')\n\treturn path.reduce((object, key) => object != null ? object[key] : object, object)\n}","import hasOwnProperty from 'utils/object/has-own-property'\nimport {signature, targetFn} from 'symbols'\n\nmap[signature] = 'map :: (α, ?Integer, ?List L → β) → [α] L, ?Boolean = L.map !== map → [β]'\n\nexport default function map (iteratee, collection, useMethod = (collection.map[targetFn] || collection.map) !== map) {\n\tif (typeof collection.map === 'function' && useMethod) // objects with map method (array, functor/monad, etc.)\n\t\treturn collection.map(iteratee) \n\n\tconst mapped = new (collection.constructor) // default mapping\n\tfor (let key in collection)\n\t\tif (hasOwnProperty(collection, key))\n\t\t\tmapped[key] = iteratee(collection[key], key, collection)\n\treturn mapped\n}\n","export default function apply (fn, context, args) {\n\tswitch (args.length) {\n\t\tcase 0:\n\t\t\treturn fn.call(context)\n\t\tcase 1:\n\t\t\treturn fn.call(context, args[0])\n\t\tcase 2:\n\t\t\treturn fn.call(context, args[0], args[1])\n\t\tcase 3:\n\t\t\treturn fn.call(context, args[0], args[1], args[2])\n\t\tcase 4:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3])\n\t\tcase 5:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4])\n\t\tcase 6:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5])\n\t\tcase 7:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6])\n\t\tcase 8:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])\n\t\tcase 9:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])\n\t\tdefault:\n\t\t\treturn fn.apply(context, args)\n\t}\n}\n","/* global Object: false */\n\nexport default function arrayConcat (a, b, placeholder) {\n\tconst aLength = a.length\n\tconst bLength = b.length\n\tconst array = Array() // cannot guess final length, because of placeholders\n\n\tfor (let i = 0, j = 0; i < aLength || j < bLength; i++)\n\t\tarray[i] = i >= aLength || a[i] === placeholder ? b[j++] : a[i]\n\n\treturn array\n}\n","export default function getLength (list, max, placeholder) {\n\tlet length = 0\n\tlet index = list.length\n\tindex > max && (index = max)\n\n\twhile (index--)\n\t\tlist[index] !== placeholder && length++\n\n\treturn length\n}\n","import apply from 'utils/optims/apply'\n\n/* global Error: false */\n\nexport default function setArity (arity, fn) {\n\tarity >= 0 || (arity = 0)\n\tswitch (arity) {\n\t\tcase 0:\n\t\t\treturn function nullary () {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 1:\n\t\t\treturn function unary (a) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 2:\n\t\t\treturn function binary (a, b) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 3:\n\t\t\treturn function ternary (a, b, c) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 4:\n\t\t\treturn function quaternary (a, b, c, d) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 5:\n\t\t\treturn function quinary (a, b, c, d, e) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 6:\n\t\t\treturn function senary (a, b, c, d, e, f) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 7:\n\t\t\treturn function septenary (a, b, c, d, e, f, g) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 8:\n\t\t\treturn function octonary (a, b, c, d, e, f, g, h) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 9:\n\t\t\treturn function novenary (a, b, c, d, e, f, g, h, i) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow Error(`Arity \"${arity}\" is not supported`) // wtf arity >= 10\n\t}\n}\n","/* global Array: false */\n\nexport default function toArray (list, length = list.length) {\n\tconst array = Array(length)\n\n\twhile (length--)\n\t\tarray[length] = list[length]\n\n\treturn array\n}\n","import {setArity, arrayConcat, apply, getLength} from 'optims'\nimport {signature, targetFn, boundThis, partialArgs, placeholder} from 'symbols'\n\npartial[signature] = partialDebug[signature] = 'partial :: (α1, …, αN → β), ?[α1, …] = [] → (…, αN → β)'\n\npartial.placeholder = partialDebug.placeholder = placeholder\n\npartial.debug = partialDebug\n\nexport function partialDebug (fn, args = []) {\n\tconst applied = partial(fn, args)\n\n\t/* attach debug info */\n\tconst target = fn[targetFn] || fn\n\tapplied.toString = () => `/* partially applied */${target}`\n\tapplied[signature] = target[signature]\n\tapplied[targetFn] = target\n\tapplied[boundThis] = this\n\tapplied[partialArgs] = args\n\n\treturn applied\n}\n\nexport default function partial (fn, args = []) {\n\tconst length = fn.length\n\n\treturn setArity(length - getLength(args, length, placeholder), function partiallyApplied () {\n\t\treturn apply(fn, this, arrayConcat(args, arguments, placeholder))\n\t})\n}\n","import {setArity, apply, getLength} from 'optims'\nimport {signature, targetFn, placeholder} from 'symbols'\nimport partial, {partialDebug} from 'partial'\n\nconst curry = curryFactory(partial)\nconst curryDebug = curryFactory(partialDebug, debug)\n\ncurry[signature] = curryDebug[signature] = 'curry :: (α1, …, αN → β) A, ?Number N = A.length → (α1 → … → αN → β)'\n\ncurry.placeholder = curryDebug.placeholder = placeholder\n\ncurry.debug = curryDebug\n\nfunction curryFactory (partial, wrapper) {\n\treturn function curry (fn, arity = fn.length) {\n\t\tarity = parseInt(arity, 10) || 0\n\n\t\tconst _curried = setArity(arity, function curried () {\n\t\t\treturn getLength(arguments, arity, placeholder) === arity ?\n\t\t\t\tapply(fn, this, arguments) :\n\t\t\t\tpartial.call(this, _curried, arguments)\n\t\t})\n\n\t\treturn wrapper ? wrapper(_curried, fn) : _curried\n\t}\n}\n\nfunction debug (curried, fn) {\n\t/* attach debug info */\n\tconst target = fn[targetFn] || fn\n\tcurried.toString = () => `/* curried */${target}`\n\tcurried[signature] = target[signature]\n\tcurried[targetFn] = target\n\n\treturn curried\n}\n\nexport {curryDebug}\n\nexport default curry\n","import {setArity, toArray, arrayConcat, apply} from 'optims'\nimport {signature, targetFn, boundThis} from 'symbols'\nimport map from 'utils/map'\nimport trace from 'utils/trace'\n\ncompose[signature] = composeDebug[signature] = composeTrace[signature] = \n'compose :: (…, αN → β), …, (α1, … → α2) → (α1, … → β)'\n\ncompose.debug = composeDebug\n\ncompose.trace = composeTrace\n\nfunction composer (args, fn) {\n\treturn arrayConcat(\n\t\t[apply(fn, this, toArray(args, fn.length || args.length))],\n\t\t[].slice.call(args, fn.length || 1)\n\t)\n}\n\nexport function composeTrace () {\n\treturn apply(compose, this, map((fn) => trace('compose', fn), arguments))\n}\n\nexport function composeDebug () {\n\tconst composed = apply(compose, null, arguments)\n\tconst last = arguments[arguments.length - 1]\n\n\t/* attach debug info */\n\tconst target = last[targetFn] || last\n\tcomposed.toString = () => `/* composed */${target}`\n\tcomposed[signature] = target[signature]\n\tcomposed[targetFn] = target\n\n\treturn composed\n}\n\nexport default function compose () {\n\tconst functions = toArray(arguments)\n\tconst last = arguments[arguments.length - 1]\n\n\treturn setArity(last && last.length || 0, function composed () {\n\t\treturn functions.reduceRight(composer, arguments).shift()\n\t})\n}\n","import {setArity, apply} from 'optims'\nimport {signature} from 'symbols'\n\narity[signature] = 'arity :: (α1, …, αN → β) F, ?Number A = F.length → (α1, …, αA → β)'\n\nexport default function arity (fn, arity = fn.length) {\n\treturn setArity(arity, function Nary () {\n\t\targuments.length = arity\n\t\treturn apply(fn, this, arguments)\n\t})\n}","import {setArity, apply} from 'optims'\nimport {signature} from 'symbols'\n\nnot[signature] = 'not :: (α1, …, αN → β) → (α1, …, αN → Boolean !β)'\n\nexport default function not (fn) {\n\treturn setArity(fn.length, function not () {\n\t\treturn !apply(fn, this, arguments)\n\t})\n}\n","import {signature} from 'symbols'\n\nnoop[signature] = 'noop :: α → undefined'\n\nexport default function noop () {}\n","import {signature} from 'symbols'\n\nidentity[signature] = 'identity :: α → α'\n\nexport default function identity (value) {\n\treturn value\n}\n","import {signature} from 'symbols'\n\nconstant[signature] = 'constant :: α → β → α'\n\nexport default function constant (value) {\n\treturn () => value\n}\n","export { default as noop } from 'functions/noop'\nexport { default as identity } from 'functions/identity'\nexport { default as constant } from 'functions/constant'\n","import hasOwnProperty from 'utils/object/has-own-property'\n\nexport const filters = {\n\tcontains: (b) => (a) => String.prototype.indexOf.call(a, b) > -1\n\t, in:     (b) => (a) => String.prototype.indexOf.call(b, a) > -1\n\t, eq:     (b) => (a) => a === b\n\t, not:    (b) => (a) => a !== b\n\t, gte:    (b) => (a) => a >= b\n\t, lte:    (b) => (a) => a <= b\n\t, gt:     (b) => (a) => a > b\n\t, lt:     (b) => (a) => a < b\n\t, mod:    (b) => (a) => a % b\n\t, odd:    (a) => a % 2\n}\n\nconst assignKey = (object, value, key) => (object[key] = value, object)\nconst pushValue = (array, value) => (array.push(value), array)\n\nfunction first () { return  true }\nfunction tupple (value, index) { return [index, value] }\nfunction byIndex (index) { return (_, i) => index === i }\n\nconst callback = (x) => {\n\tswitch (typeof x) {\n\t\tcase 'function':\n\t\t\treturn x\n\t\tcase 'string':\n\t\t\treturn (item) => item[x]\n\t\tcase 'object':\n\t\t\tconst sequence = Collection.from(x)\n\t\t\treturn (item) => sequence.every((value, key) => item[key] === value)\n\t\tcase 'undefined':\n\t\t\treturn (item) => item\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid callback ${x}`)\n\t}\n}\n\nexport function Collection (source) {\n\tthis.source = source\n}\n\nCollection.prototype = {\n\tfilter (predicate) { return new FilteredCollection(this, predicate) }\n\t, unique () {\n\t\tconst unique = []\n\t\treturn this.filter((value) => unique.indexOf(value) < 0 && unique.push(value)) // TODO indexOf perf\n\t}\n\t, map (mapper) { return new MappedCollection(this, mapper) }\n\t, entries() { return this.map(tupple) }\n\t, slice (start, end) {\n\t\tend === undefined && hasOwnProperty(this, 'length') && (end = this.length)\n\t\tif (start < 0 || end < 0) {\n\t\t\tif (!('length' in this))\n\t\t\t\treturn Collection.from(this.valueOf()).slice(start, end)\n\t\t\tstart < 0 && (start += this.length)\n\t\t\tend  = end < 0 ? (end + this.length) : end || this.length\n\t\t}\n\t\treturn new SlicedCollection(this, start || 0, end)\n\t}\n\t, find (predicate) {\n\t\tlet found\n\t\tthis.forEach(function lookup (value, key) {\n\t\t\tif (predicate(value, key))\n\t\t\t\treturn found = value, false\n\t\t})\n\t\treturn found\n\t}\n\t, some (predicate) {\n\t\tthis.forEach((value, key) => predicate(value, key) ? (predicate = false) : null)\n\t\treturn !predicate\n\t}\n\t, every (predicate) { return !this.some(function not (value, key) { return !predicate(value, key) }) }\n\t, reduce (reducer, accumulator) {\n\t\tif (arguments.length < 2)\n\t\t\treturn this.slice(1).reduce(reducer, this.find(first)) // eg. head\n\t\tthis.forEach(function accumulate (value, key) { accumulator = reducer(accumulator, value, key) })\n\t\treturn accumulator\n\t}\n\t// , concat () {\n\t// \treturn new ConcatenatedCollection(this, arguments)\n\t// }\n\t, toArray () { return this.reduce(pushValue, hasOwnProperty(this, 'length') ? new Array(this.length) : []) }\n\t, toString () { return this.toArray().join('') }\n\t, toObject () { return this.reduce(assignKey, {}) }\n\t, toJSON () { return this.valueOf() }\n\t, value () { return this.toArray() } // lodash compatibility\n\t, valueOf () {\n\t\tlet source = this.source\n\t\twhile (source.valueOf === Collection.prototype.valueOf)\n\t\t\tsource = source.source\n\t\treturn source.valueOf.call(this)\n\t}\n}\n\nfunction IndexedCollection (index) {\n\tCollection.call(this, index)\n\tthis.length = index.length\n}\n\nIndexedCollection.prototype = Object.create(Collection.prototype, {\n\tvalueOf: { value: function valueOf () { return this.source } }\n\t, forEach: { value: function forEach (iteratee) {\n\t\tlet index = -1\n\t\tconst source = this.source\n\t\tconst length = this.length\n\t\twhile (++index < length)\n\t\t\tif (false === iteratee(source[index], index))\n\t\t\t\tbreak\n\t\treturn this\n\t} }\n\t, has: { value: function has (index) { return hasOwnProperty(this.source, index) } }\n\t, get: { value: function get (index) { return this.source[index] } }\n\t// optimization\n\t, filter: { value: function filter (predicate) { return new FilteredIndexCollection(this, predicate) } }\n})\n\nfunction ArrayCollection (array) {\n\tIndexedCollection.call(this, array)\n}\n\nArrayCollection.prototype = Object.create(IndexedCollection.prototype, {\n\tvalueOf: { value: function valueOf () { return this.toArray() } }\n\t, toArray: { value: function toArray () { return this.source } }\n})\n\nfunction StringCollection (string) {\n\tIndexedCollection.call(this, string)\n}\n\nStringCollection.prototype = Object.create(IndexedCollection.prototype, {\n\tvalueOf: { value: function valueOf () { return this.toString() } }\n\t, toString: { value: function toString () { return this.source } }\n\t, get: { value: function get (index) { return this.source.charAt(index) } }\n})\n\nfunction ObjectCollection (object) {\n\tCollection.call(this, object)\n}\n\nObjectCollection.prototype = Object.create(Collection.prototype, {\n\tvalueOf: { value: function valueOf () { return this.toObject() } }\n\t, toObject: { value: function toObject () { return this.source } }\n\t, forEach: { value: function forEach (iteratee) {\n\t\tconst object = this.source\n\t\tfor (let key in object)\n\t\t\tif (false === iteratee(object[key], key))\n\t\t\t\tbreak\n\t\treturn this\n\t} }\n\t, has: { value: IndexedCollection.prototype.has }\n\t, get: { value: IndexedCollection.prototype.get }\n\t, length: { get: function length () { return this._length || (this._length = Object.keys(this.source).length) } }\n})\n\nfunction IteratorCollection (iterator) {\n\tCollection.call(this, iterator)\n}\n\nIteratorCollection.prototype = Object.create(Collection.prototype, {\n\tvalueOf: { value: function valueOf () { return this } }\n\t, forEach: { value: function forEach (iteratee) {\n\t\tconst iterator = this.source()\n\t\tlet index = -1\n\t\tlet result\n\t\twhile ((result = iterator.next()) && !result.done)\n\t\t\tif (false === iteratee(result.value, ++index))\n\t\t\t\tbreak\n\t\treturn this\n\t} }\n\t, has: { value: function has (index) { return this.some(byIndex(index)) } }\n\t, get: { value: function get (index) { return this.find(byIndex(index)) } }\n})\n\nfunction FilteredCollection (collection, predicate) {\n\tCollection.call(this, collection)\n\tthis.predicate = callback(predicate)\n}\n\nFilteredCollection.prototype = Object.create(Collection.prototype, {\n\tforEach: { value: function forEach (iteratee) {\n\t\tconst predicate = this.predicate\n\t\tlet filteredIndex = -1\n\t\tthis.source.forEach(function filteredIteratee (value, index) {\n\t\t\tif (predicate(value, index))\n\t\t\t\treturn iteratee(value, typeof index === 'number' ? ++filteredIndex : index)\n\t\t})\n\t\treturn this\n\t} }\n\t, filter: { value: function filter (predicate) { // filter composition optimization\n\t\tpredicate = callback(predicate)\n\t\tconst parentPredicate = this.predicate\n\t\treturn this.source.filter(function composedPredicate (value, index) {\n\t\t\treturn parentPredicate(value, index) && predicate(value, index)\n\t\t})\n\t} }\n\t, has:  { value: function has (index) { return this.source.has(index) && this.predicate(this.source.get(index), index) } }\n\t, get: { value: function get (index) {\n\t\tconst value = this.source.get(index)\n\t\treturn this.predicate(value, index) ? value : undefined\n\t} }\n\t, length: { get: function length () { return this.toArray().length } }\n})\n\n// optimization \nfunction FilteredIndexCollection (collection, predicate) {\n\tFilteredCollection.call(this, collection, predicate)\n}\n\nFilteredIndexCollection.prototype = Object.create(FilteredCollection.prototype, {\n\tforEach: { value: function forEach (iteratee) {\n\t\tconst source = this.source.source\n\t\tconst predicate = this.predicate\n\t\tconst length = source.length\n\t\tlet filteredIndex = -1\n\t\tlet sourceIndex = -1\n\t\tlet value\n\t\twhile (++sourceIndex < length) {\n\t\t\tvalue = source[sourceIndex]\n\t\t\tif (predicate(value, sourceIndex) && false === iteratee(value, ++filteredIndex))\n\t\t\t\tbreak\n\t\t}\n\t\treturn this\n\t} }\n\t// , get: { value: function get (index) {\n\t// \tconst value = this.source[index]\n\t// \treturn this.predicate(value, index) ? value : undefined\n\t// } }\n})\n\nfunction MappedCollection (collection, mapper) {\n\tCollection.call(this, collection)\n\tthis.mapper = callback(mapper)\n}\n\nMappedCollection.prototype = Object.create(Collection.prototype, {\n\tforEach: { value: function forEach (iteratee) {\n\t\tconst mapper = this.mapper\n\t\tthis.source.forEach(function mappedIteratee (value, index) {\n\t\t\treturn iteratee(mapper(value, index), index)\n\t\t})\n\t\treturn this\n\t} }\n\t, map: { value: function map (mapper) { // map composition optimization\n\t\tmapper = callback(mapper)\n\t\tconst parentMapper = this.mapper\n\t\treturn this.source.map(function composedMapper (value, index) {\n\t\t\treturn mapper(parentMapper(value, index), index)\n\t\t})\n\t} }\n\t, has: { value: function has (index) { return this.source.has(index) } }\n\t, get: { value: function get (index) {\n\t\tif(this.has(index))\n\t\t\treturn this.mapper(this.source.get(index), index)\n\t} }\n\t, length: { get: function length () { return this.source.length } }\n})\n\nfunction SlicedCollection (collection, start, end) {\n\tCollection.call(this, collection)\n\tthis.start = start\n\tthis.end = end\n}\n\nSlicedCollection.prototype = Object.create(Collection.prototype, {\n\tforEach: { value: function forEach (iteratee) {\n\t\tconst end = this.end\n\t\tlet sliceIndex = -1 - this.start\n\t\tthis.source.forEach(function slicedIteratee (value, index) {\n\t\t\tif (++sliceIndex < 0)\n\t\t\t\treturn\n\t\t\treturn sliceIndex < end && iteratee(value, typeof index === 'number' ? sliceIndex : index)\n\t\t})\n\t\treturn this\n\t} }\n\t, has: { value: function has (index) { return 0 <= index && index < this.length && this.source.has(index - this.start) } }\n\t, get: { value: function get (index) {\n\t\tif(0 <= index && index < this.length)\n\t\t\treturn this.source.get(index - this.start)\n\t} }\n\t, length: { get: function length () { return this.end && Math.max(this.end - this.start, 0) } }\n})\n\nfunction getIterator (value) {\n\tif (value != null) {\n\t\tif (typeof value[Symbol.iterator] === 'function') // value has an iterator (ex: array, string, generator)\n\t\t\treturn () => value[Symbol.iterator]()\n\t\tif (typeof value.next === 'function') // value implements iterator protocol\n\t\t\treturn () => value\n\t\tif (typeof value === 'function') // value may be a generator, better test may be Object.getPrototypeOf(value) === Object.getPrototypeOf(function*() {})\n\t\t\treturn value\n\t}\n\treturn () => ({ next () { return { done: true } } })\n}\n\n/* global Array: false, Object: false */\n\nexport default Collection.from = (value) => {\n\tif (Array.isArray(value))\n\t\treturn new ArrayCollection(value) // collection specialized for array\n\tif (typeof value === 'string')\n\t\treturn new StringCollection(value) // collection specialized for string\n\tif (typeof value === 'object' && value.constructor === Object)\n\t\treturn new ObjectCollection(value) // collection specialized for object\n\treturn new Collection(getIterator(value))\n}\n","import { version } from '../package.json'\nimport assign from 'utils/object/assign'\nimport equals from 'utils/object/_equals'\nimport doc from 'utils/doc'\nimport trace from 'utils/trace'\nimport path from 'utils/path'\nimport map from 'utils/map'\nimport {placeholder} from 'symbols'\nimport partial from 'partial'\nimport curry from 'curry'\nimport compose from 'compose'\nimport arity from 'arity'\nimport not from 'not'\nimport * as functions from 'functions'\n\nimport collection, {filters} from './collection'\n\nexport default assign(\n\tcollection\n\t, {\n\t\tversion\n\t\t, f: filters\n\t\t, placeholder\n\t\t, doc\n\t\t, partial, curry, compose, arity, not\n\t}\n\t, functions\n\t, map((fn) => curry.debug(fn), { trace, path, equals, map })\n)\n"],"names":["getProperties","object","const","properties","getPrototype","Array","prototype","push","apply","Object","getOwnPropertyNames","concat","getOwnPropertySymbols","filter","property","indexOf","equals","a","b","aType","is","aProperties","bProperties","aValue","valueOf","bValue","aContainValue","bContainValue","length","every","key","doc","fn","signature","name","toString","call","trace","tag","value","console","log","path","isArray","String","split","reduce","map","iteratee","collection","useMethod","targetFn","mapped","let","hasOwnProperty","context","args","arrayConcat","placeholder","aLength","bLength","array","i","j","getLength","list","max","index","setArity","arity","this","arguments","c","d","e","f","g","h","Error","toArray","partialDebug","applied","partial","target","boundThis","partialArgs","curryFactory","wrapper","parseInt","_curried","debug","curried","composer","slice","composeTrace","compose","composeDebug","composed","last","functions","reduceRight","shift","not","noop","identity","constant","Collection","source","IndexedCollection","predicate","mapper","start","end","Function","bind","assign","getPrototypeOf","Symbol","curry","curryDebug","in","eq","unique","MappedCollection","entries","from","forEach","reducer","toObject","StringCollection","create","parentPredicate","parentMapper","get","sliceIndex","Math","filters"],"mappings":"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"}