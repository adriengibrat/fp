{"version":3,"file":"fp.min.js","sources":["../package.json","../src/utils/object/has-own-property.js","../src/utils/object/assign.js","../src/utils/object/is.js","../src/utils/object/get-prototype.js","../src/utils/object/_equals.js","../../../../../../src/utils/_symbols.js","../src/utils/doc.js","../src/utils/trace.js","../src/utils/path.js","../src/utils/map.js","../../../../../../src/utils/_optims.js","../src/partial.js","../src/curry.js","../src/compose.js","../src/arity.js","../src/not.js","../src/functions/noop.js","../src/functions/identity.js","../src/functions/constant.js","../../../../../../src/functions/index.js","../src/collection.js","../src/index.js"],"sourcesContent":["{\n  \"name\": \"fp\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Readable, debbuggable & fast ES6 Functional Programming\",\n  \"author\": \"Adrien Gibrat <adrien.gibrat@gmail.com>\",\n  \"license\": \"MIT\",\n  \"main\": \"fp.js\",\n  \"jsnext:main\": \"src/index.js\",\n  \"engines\": {\n    \"npm\": \">= 2.0.0\"\n  },\n  \"eslintConfig\": {\n    \"env\": {\n      \"browser\": true,\n      \"es6\": true\n    },\n    \"parserOptions\": {\n      \"ecmaVersion\": 6,\n      \"sourceType\": \"module\"\n    }\n  },\n  \"scripts\": {\n    \"start\": \"npm run watch\",\n    \"bench\": \"npm run bench:curry && npm run bench:collection\",\n    \"bench:curry\": \"node bench/curry.bench.js\",\n    \"bench:collection\": \"node bench/collection.bench.js\",\n    \"build\": \"npm run build:core && npm run build:core:min && npm run build:monads && npm run build:monads:min\",\n    \"build:core\": \"rollup --config --id fp --input src/index.js --output dist/fp.js\",\n    \"build:core:min\": \"rollup --config --environment BUILD:min --id fp --input src/index.js --output dist/fp.min.js\",\n    \"build:monads\": \"rollup --config --id fp.monads --globals fp:fp --input src/index.monads.js --output dist/fp.monads.js\",\n    \"build:monads:min\": \"rollup --config --environment BUILD:min --id fp.monads --globals fp:fp --input src/index.monads.js --output dist/fp.monads.min.js\",\n    \"check\": \"check-dependencies --verbose\",\n    \"perf\": \"npm run perf:init && npm run perf:collection\",\n    \"perf:init\": \"grep 1 /proc/sys/kernel/kptr_restrict > /dev/null && sudo sh -c 'echo 0 > /proc/sys/kernel/kptr_restrict && echo 1 > /proc/sys/kernel/perf_event_paranoid' || echo 'perf init already done'\",\n    \"perf:collection:record\": \"perf record -F 1000 -i -g -e cycles:u -- node --perf-basic-prof perf/collection.perf.js && npm run perf:script\",\n    \"perf:script\": \"LANG=C perf script | egrep -v '( __libc_start| LazyCompile | v8::internal::| Builtin:| Stub:| LoadIC:|\\\\[unknown\\\\]| LoadPolymorphicIC:)' | stackcollapse-perf 2>/dev/null | grep run_perf | sed 's/LazyCompile:[*~]\\\\?//g;s/node`//g;s|'$PWD'/||g;s/^.*run_perf//' > perf/script.collapsed.txt\",\n    \"perf:collection:flamegraph\": \"stackvis collapsed < perf/script.collapsed.txt > perf/collection.flamegraph.html\",\n    \"perf:collection\": \"npm run perf:collection:record && npm run perf:collection:flamegraph\",\n    \"size\": \"npm run size:core --silent && npm run size:core:min --silent && npm run size:monads --silent && npm run size:monads:min --silent\",\n    \"size:core\": \"echo \\\"fp raw size `cat dist/fp.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:core:min\": \"echo \\\"fp minified & gzipped `gzip -9 -c dist/fp.min.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:monads\": \"echo \\\"fp.monads raw size `cat dist/fp.monads.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"size:monads:min\": \"echo \\\"fp.monads minified & gzipped `gzip -9 -c dist/fp.monads.min.js | wc -c | numfmt --to=iec-i --suffix=B`\\\"\",\n    \"test\": \"npm run test:partial && npm run test:curry && npm run test:compose\",\n    \"test:partial\": \"node test/partial.test.js\",\n    \"test:curry\": \"node test/curry.test.js\",\n    \"test:compose\": \"node test/compose.test.js\",\n    \"watch\": \"chokidar 'src/**/*.js' --command 'time npm run build:core --silent && echo \\\"build core done\\\" && time npm run build:monads --silent && echo \\\"build monads done\\\"'\",\n    \"watch:core\": \"chokidar 'src/**/*.js' --command 'time npm run build:core --silent && echo \\\"build core done\\\"'\",\n    \"watch:monads\": \"chokidar 'src/**/*.js' --command 'time npm run build:monads --silent && echo \\\"build monads done\\\"'\"\n  },\n  \"devDependencies\": {\n    \"check-dependencies\": \"^0.12.0\",\n    \"chokidar-cli\": \"^1.2.0\",\n    \"rollup\": \"^0.26.1\",\n    \"rollup-plugin-buble\": \"^0.6.0\",\n    \"rollup-plugin-eslint\": \"^2.0.0\",\n    \"rollup-plugin-includepaths\": \"^0.1.2\",\n    \"rollup-plugin-json\": \"^2.0.0\",\n    \"rollup-plugin-uglify\": \"^0.3.1\",\n    \"tape\": \"^4.5.1\"\n  },\n  \"optionalDependencies\": {\n    \"benchmark\": \"^2.1.0\",\n    \"flamegraph\": \"^0.7.0\",\n    \"lazy.js\": \"^0.4.2\",\n    \"lodash\": \"^4.11.2\",\n    \"ramda\": \"^0.19.1\",\n    \"stackvis\": \"^0.3.0\"\n  }\n}\n","/* global Object: false, Function: false */\n\nexport default Function.call.bind(Object.prototype.hasOwnProperty)\n","import hasOwnProperty from 'utils/object/has-own-property'\n\n/* global Object: false */\n\nexport default Object.assign || function assign (target) {\n\tfor (let index = 1; index < arguments.length; index++) {\n\t\tlet source = arguments[index]\n\t\tif (source != null)\n\t\t\tfor (let key in source)\n\t\t\t\tif (hasOwnProperty(source, key))\n\t\t\t\t\ttarget[key] = source[key]\n\t}\n\treturn target\n}\n","/* global Object: false */\n\nexport default Object.is || function is (a, b) {\n\treturn a === b ?\n\t\t//+0 !== -0\n\t\ta !== 0 || 1 / a === 1 / b :\n\t\t// NaN === NaN\n\t\ta !== a && b !== b\n}\n","/* global Object: false */\n\nexport default Object.getPrototypeOf\n","import is from 'utils/object/is'\nimport getPrototype from 'utils/object/get-prototype'\n\n/* global Object: false, Array: false */\n\nfunction getProperties (object) {\n\tconst properties = []\n\tfor (; object != null; object = getPrototype(object))\n\t\tArray.prototype.push.apply(\n\t\t\tproperties,\n\t\t\tObject.getOwnPropertyNames(object).concat(Object.getOwnPropertySymbols(object))\n\t\t\t\t.filter((property) => properties.indexOf(property) === -1)\n\t\t)\n\treturn properties\n}\n\nexport default function equals (a, b) {\n\tconst aType = typeof a\n\tif (aType !== typeof b)\n\t\treturn false\n\tif (is(a, b))\n\t\treturn true\n\tif (aType !== 'object')\n\t\treturn false\n\tconst aProperties = getProperties(a)\n\tconst bProperties = getProperties(b)\n\tconst aValue = typeof a.valueOf === 'function' && a.valueOf()\n\tconst bValue = typeof b.valueOf === 'function' && b.valueOf()\n\tconst aContainValue = aValue !== a\n\tconst bContainValue = bValue !== b\n\n\treturn aProperties.length === bProperties.length\n\t\t&& aProperties.every((key) => equals(a[key], b[key]))\n\t\t&& (aContainValue && bContainValue ? equals(aValue, bValue) : true)\n}\n","export const signature = Symbol('signature')\nexport const targetFn = Symbol('targetFn')\nexport const boundThis = Symbol('boundThis')\nexport const partialArgs = Symbol('partialArgs')\nexport const placeholder = Symbol('placeholder')\n","import {signature} from 'symbols'\n\ndoc[signature] = 'doc :: (* → *) → String'\n\n/* global Object: false */\n\nexport default function doc (fn) {\n\treturn `doc ${fn && (fn[signature] || fn.name) || Object.prototype.toString.call(fn)}`\n}\n\n/*\n// SEE http://www.cjandia.com/2012/06/x-calc/dhm/lib/?types.js\nconst _funcNamePattern = /^([^:\\s]+)\\s*::\\s+/\nconst _separatorPattern = /\\s*→\\s+/\nconst _namePattern = /\\s+([a-zA-Z0-9]+)\\s+/ // *Definition* Name\n//const _typePattern = /\\s*[a-z\\d]+\\s*$/i // Type *Definition*\nconst _argumentsPattern = /\\s*,\\s+/\nconst _optionalPattern = /^\\?\\s*([^\\s])(?:\\s*([^=]))?(?:\\s*=\\s*(.*))?/ // ?*Type* *Name* = *Default*\nconst _listPattern = /\\[([^\\]])\\]/ // [*Definition*]\nfunction _parseArgs (signature) {\n\tlet deepParenthesis = 0\n\tlet deepList = 0\n\tlet offset = 0\n\n\tsignature.arguments = [].reduce.call(signature.source, function parser (args, char, index, string) {\n\t\tconst openParenthesis = char === '('\n\t\tconst closeParenthesis = char === ')'\n\t\tconst openList = char === '['\n\t\tconst closeList = char === ']'\n\t\tconst separator = char === '→' || char === ','\n\t\t// const optional = char === '?'\n\t\t// const defaultValue = char === '='\n\t\tconst end = index === string.length - 1\n\n\t\tconst source = string.slice(offset ? offset : offset + 1, index)\n\t\tlet parsed = []\n\n\t\tcloseParenthesis && deepParenthesis--\n\t\tcloseList && deepList--\n\n\t\tif (closeParenthesis && !deepParenthesis) { // parenthesis group\n\t\t\tparsed = _parseArgs({source})\n\n\t\t\tconst named = string.slice(index + 1).match(_namePattern)\n\t\t\tif (named) {\n\t\t\t\tindex += named[0].length\n\t\t\t\tparsed.name = named[1]\n\t\t\t}\n\n\t\t\tparsed.source = string.slice(offset ? offset - 1 : offset, index + 1).trim()\n\n\t\t\toffset = index + 1\n\t\t} else if (closeList && !deepList) { // list\n\t\t\tparsed = _parseArgs({source})\n\n\t\t\tparsed.type = 'List'\n\t\t\tparsed.of = source\n\t\t\tparsed.source = string.slice(offset ? offset - 1 : offset, index + 1)\n\n\t\t\toffset = index + 1\n\t\t} else if (!deepParenthesis && !deepList && separator || end) { // flat signature\n\t\t\tparsed = [string\n\t\t\t\t.slice(offset, index).trim()]\n\t\t\t\t//.split(_separatorPattern)\n\t\t\t\t//.reduce((args, arg) => args\n\t\t\t\t//\t.concat(arg.split(_argumentsPattern).filter(Boolean))\n\t\t\t\t//, [])\n\t\t\t\t.map((string)=> ({ source: string }))\n\t\t\t\t// .map((item) => { // handle list type\n\t\t\t\t// \tconst list = item.source.match(_listPattern)\n\t\t\t\t// \tif (list) {\n\t\t\t\t// \t\titem.type = 'List'\n\t\t\t\t// \t\titem.of = list[1]\n\t\t\t\t// \t}\n\t\t\t\t// \treturn item\n\t\t\t\t// })\n\t\t\t\t.map((item) => { // handle optional params\n\t\t\t\t\tconst optional = item.source.match(_optionalPattern)\n\t\t\t\t\tif (optional) {\n\t\t\t\t\t\titem.optional = true\n\t\t\t\t\t\titem.type = optional[2] && optional[1]\n\t\t\t\t\t\titem.name = optional[2] || optional[1]\n\t\t\t\t\t\titem.default = optional[3]\n\t\t\t\t\t}\n\t\t\t\t\treturn item\n\t\t\t\t})\n\t\t\t\t.map((item) => { // guess name & type\n\t\t\t\t\tif (!item.name)\n\t\t\t\t\t\titem.name = item.source\n\t\t\t\t\tif (!item.type && item.name.length > 2) {\n\t\t\t\t\t\titem.type = item.name\n\t\t\t\t\t\tdelete item.name\n\t\t\t\t\t}\n\t\t\t\t\treturn item\n\t\t\t\t})\n\n\t\t\toffset = index + 1\n\t\t}\n\n\t\topenParenthesis && deepParenthesis++\n\t\topenList && deepList++\n\n\t\treturn args.concat(parsed)\n\t}, [])\n\t\t.filter(Boolean)\n\n\tif (signature.arguments.length > 1) {\n\t\tsignature.type = 'Function'\n\t\tsignature.return = signature.arguments.pop()\n\t\tsignature.arity = signature.arguments.find((arg) => arg.source === '…') ?\n\t\t\t'variadic' :\n\t\t\tsignature.arguments.filter((arg) => !arg.optional).length\n\t}\n\n\treturn signature\n}\n\n\ndoc._parse = (fn) => {\n\tlet name\n\tconst _signature = fn && fn[signature]\n\tconst parsed = _signature && _parseArgs({\n\t\tsource: _signature.replace(_funcNamePattern, (_, _name) => (name = _name, ''))\n\t})\n\tparsed && (parsed.name = name)\n\treturn parsed\n}\n//*/\n","import {signature} from 'symbols'\n\ntrace[signature] = 'trace :: String → α → α'\n\n/* global console: false */\n\nexport default function trace (tag, value) {\n\tconsole.log(`${tag} %1$O\\n%1$s`, value)\n\treturn value\n}\n","/* global String: false */\n\nexport default function path (path, object) {\n\tif(!Array.isArray(path))\n\t\tpath = String.prototype.split.call(path, '.')\n\treturn path.reduce((object, key) => object != null ? object[key] : object, object)\n}","import hasOwnProperty from 'utils/object/has-own-property'\nimport {signature, targetFn} from 'symbols'\n\nmap[signature] = 'map :: (α, ?Integer, ?List L → β) → [α] L, ?Boolean = L.map !== map → [β]'\n\nexport default function map (iteratee, collection, useMethod = (collection.map[targetFn] || collection.map) !== map) {\n\tif (typeof collection.map === 'function' && useMethod) // objects with map method (array, functor/monad, etc.)\n\t\treturn collection.map(iteratee) \n\n\tconst mapped = new (collection.constructor) // default mapping\n\tfor (let key in collection)\n\t\tif (hasOwnProperty(collection, key))\n\t\t\tmapped[key] = iteratee(collection[key], key, collection)\n\treturn mapped\n}\n","export function apply (fn, context, args) {\n\tswitch (args.length) {\n\t\tcase 0:\n\t\t\treturn fn.call(context)\n\t\tcase 1:\n\t\t\treturn fn.call(context, args[0])\n\t\tcase 2:\n\t\t\treturn fn.call(context, args[0], args[1])\n\t\tcase 3:\n\t\t\treturn fn.call(context, args[0], args[1], args[2])\n\t\tcase 4:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3])\n\t\tcase 5:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4])\n\t\tcase 6:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5])\n\t\tcase 7:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6])\n\t\tcase 8:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])\n\t\tcase 9:\n\t\t\treturn fn.call(context, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])\n\t\tdefault:\n\t\t\treturn fn.apply(context, args)\n\t}\n}\n\nexport function setArity (arity, fn) {\n\tarity >= 0 || (arity = 0)\n\tswitch (arity) {\n\t\tcase 0:\n\t\t\treturn function nullary () {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 1:\n\t\t\treturn function unary (a) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 2:\n\t\t\treturn function binary (a, b) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 3:\n\t\t\treturn function ternary (a, b, c) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 4:\n\t\t\treturn function quaternary (a, b, c, d) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 5:\n\t\t\treturn function quinary (a, b, c, d, e) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 6:\n\t\t\treturn function senary (a, b, c, d, e, f) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 7:\n\t\t\treturn function septenary (a, b, c, d, e, f, g) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 8:\n\t\t\treturn function octonary (a, b, c, d, e, f, g, h) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tcase 9:\n\t\t\treturn function novenary (a, b, c, d, e, f, g, h, i) {\n\t\t\t\treturn apply(fn, this, arguments)\n\t\t\t}\n\t\tdefault:\n\t\t\tthrow Error(`Arity \"${arity}\" is not supported`) // wtf arity >= 10\n\t}\n}\n\nexport function toArray (list, length = list.length) {\n\tconst array = Array(length)\n\n\twhile (length--)\n\t\tarray[length] = list[length]\n\n\treturn array\n}\n\nexport function getLength (list, max, placeholder) {\n\tlet length = 0\n\tlet index = list.length\n\tindex > max && (index = max)\n\n\twhile (index--)\n\t\tlist[index] !== placeholder && length++\n\n\treturn length\n}\n\nexport function arrayConcat (a, b, placeholder) {\n\tconst aLength = a.length\n\tconst bLength = b.length\n\tconst array = Array() // cannot guess final length, because of placeholders\n\n\tfor (let i = 0, j = 0; i < aLength || j < bLength; i++)\n\t\tarray[i] = i >= aLength || a[i] === placeholder ? b[j++] : a[i]\n\n\treturn array\n}\n","import {setArity, arrayConcat, apply, getLength} from 'optims'\nimport {signature, targetFn, boundThis, partialArgs, placeholder} from 'symbols'\n\npartial[signature] = partialDebug[signature] = 'partial :: (α1, …, αN → β), ?[α1, …] = [] → (…, αN → β)'\n\npartial.placeholder = partialDebug.placeholder = placeholder\n\npartial.debug = partialDebug\n\nexport function partialDebug (fn, args = []) {\n\tconst applied = partial(fn, args)\n\n\t/* attach debug info */\n\tconst target = fn[targetFn] || fn\n\tapplied.toString = () => `/* partially applied */${target}`\n\tapplied[signature] = target[signature]\n\tapplied[targetFn] = target\n\tapplied[boundThis] = this\n\tapplied[partialArgs] = args\n\n\treturn applied\n}\n\nexport default function partial (fn, args = []) {\n\tconst length = fn.length\n\n\treturn setArity(length - getLength(args, length, placeholder), function partiallyApplied () {\n\t\treturn apply(fn, this, arrayConcat(args, arguments, placeholder))\n\t})\n}\n","import {setArity, apply, getLength} from 'optims'\nimport {signature, targetFn, placeholder} from 'symbols'\nimport partial, {partialDebug} from 'partial'\n\nconst curry = curryFactory(partial)\nconst curryDebug = curryFactory(partialDebug, debug)\n\ncurry[signature] = curryDebug[signature] = 'curry :: (α1, …, αN → β) A, ?Number N = A.length → (α1 → … → αN → β)'\n\ncurry.placeholder = curryDebug.placeholder = placeholder\n\ncurry.debug = curryDebug\n\nfunction curryFactory (partial, wrapper) {\n\treturn function curry (fn, arity = fn.length) {\n\t\tarity = parseInt(arity, 10) || 0\n\n\t\tconst _curried = setArity(arity, function curried () {\n\t\t\treturn getLength(arguments, arity, placeholder) === arity ?\n\t\t\t\tapply(fn, this, arguments) :\n\t\t\t\tpartial.call(this, _curried, arguments)\n\t\t})\n\n\t\treturn wrapper ? wrapper(_curried, fn) : _curried\n\t}\n}\n\nfunction debug (curried, fn) {\n\t/* attach debug info */\n\tconst target = fn[targetFn] || fn\n\tcurried.toString = () => `/* curried */${target}`\n\tcurried[signature] = target[signature]\n\tcurried[targetFn] = target\n\n\treturn curried\n}\n\nexport {curryDebug}\n\nexport default curry\n","import {setArity, toArray, arrayConcat, apply} from 'optims'\nimport {signature, targetFn, boundThis} from 'symbols'\nimport map from 'utils/map'\nimport trace from 'utils/trace'\n\ncompose[signature] = composeDebug[signature] = composeTrace[signature] = \n'compose :: (…, αN → β), …, (α1, … → α2) → (α1, … → β)'\n\ncompose.debug = composeDebug\n\ncompose.trace = composeTrace\n\nfunction composer (args, fn) {\n\treturn arrayConcat(\n\t\t[apply(fn, this, toArray(args, fn.length || args.length))],\n\t\t[].slice.call(args, fn.length || 1)\n\t)\n}\n\nexport function composeTrace () {\n\treturn apply(compose, this, map((fn) => trace('compose', fn), arguments))\n}\n\nexport function composeDebug () {\n\tconst composed = apply(compose, null, arguments)\n\tconst last = arguments[arguments.length - 1]\n\n\t/* attach debug info */\n\tconst target = last[targetFn] || last\n\tcomposed.toString = () => `/* composed */${target}`\n\tcomposed[signature] = target[signature]\n\tcomposed[targetFn] = target\n\n\treturn composed\n}\n\nexport default function compose () {\n\tconst functions = toArray(arguments)\n\tconst last = arguments[arguments.length - 1]\n\n\treturn setArity(last && last.length || 0, function composed () {\n\t\treturn functions.reduceRight(composer, arguments).shift()\n\t})\n}\n","import {setArity, apply} from 'optims'\nimport {signature} from 'symbols'\n\narity[signature] = 'arity :: (α1, …, αN → β) F, ?Number A = F.length → (α1, …, αA → β)'\n\nexport default function arity (fn, arity = fn.length) {\n\treturn setArity(arity, function Nary () {\n\t\targuments.length = arity\n\t\treturn apply(fn, this, arguments)\n\t})\n}","import {setArity, apply} from 'optims'\nimport {signature} from 'symbols'\n\nnot[signature] = 'not :: (α1, …, αN → β) → (α1, …, αN → Boolean !β)'\n\nexport default function not (fn) {\n\treturn setArity(fn.length, function not () {\n\t\treturn !apply(fn, this, arguments)\n\t})\n}\n","import {signature} from 'symbols'\n\nnoop[signature] = 'noop :: α → undefined'\n\nexport default function noop () {}\n","import {signature} from 'symbols'\n\nidentity[signature] = 'identity :: α → α'\n\nexport default function identity (value) {\n\treturn value\n}\n","import {signature} from 'symbols'\n\nconstant[signature] = 'constant :: α → β → α'\n\nexport default function constant (value) {\n\treturn () => value\n}\n","export { default as noop } from 'functions/noop'\nexport { default as identity } from 'functions/identity'\nexport { default as constant } from 'functions/constant'\n","export const filter = {\n\tcontains: (b) => (a) => String.prototype.indexOf.call(a, b) > -1\n\t, in:     (b) => (a) => String.prototype.indexOf.call(b, a) > -1\n\t, eq:     (b) => (a) => a === b\n\t, not:    (b) => (a) => a !== b\n\t, gte:    (b) => (a) => a >= b\n\t, lte:    (b) => (a) => a <= b\n\t, gt:     (b) => (a) => a > b\n\t, lt:     (b) => (a) => a < b\n\t, mod:    (b) => (a) => a % b\n\t, odd:    (a) => a % 2\n}\n\nexport function Collection (iterator) {\n\tthis.iterator = iterator\n}\n\n/* global Array: false, Object:false, Infinity: false */\n\nconst assignKey = (object, value, key) => (object[key] = value, object)\n\nCollection.prototype = {\n\tconstructor: Collection\n\t, filter (predicate) {\n\t\treturn new FilteredCollection(this, predicate)\n\t}\n\t, unique () {\n\t\tconst unique = []\n\t\treturn this.filter((value) => unique.indexOf(value) < 0 && unique.push(value)) // TODO indexOf perf\n\t}\n\t, map (mapper) {\n\t\treturn new MappedCollection(this, mapper)\n\t}\n\t, slice(start, end) {\n\t\tlet index = -1\n\t\tconst tail = this.filter(() => start <= ++index)\n\t\treturn arguments.length < 2 ? tail : new SizedCollection(start > 0 ? tail : this, end - start)\n\t}\n\t, find (predicate) {\n\t\tlet found = null\n\t\tthis.forEach((value, key) => {\n\t\t\tif (predicate(value, key)) {\n\t\t\t\tfound = value\n\t\t\t\treturn false\n\t\t\t}\n\t\t})\n\t\treturn found\n\t}\n\t, some (predicate) { return this.find(predicate) !== null }\n\t, every (predicate) { return !this.find((value, key) => !predicate(value, key)) }\n\t, reduce (reducer, accumulator) {\n\t\tif (arguments.length < 2)\n\t\t\treturn this.slice(1).reduce(reducer, this.find(() => true)) // eg. head\n\t\tthis.forEach((value, key) => { accumulator = reducer(accumulator, value, key) })\n\t\treturn accumulator\n\t}\n\t// , concat () {\n\t// \treturn new this.constructor(() => {\n\t// \t\tconst iterators = arguments\n\t// \t\tlet iterator = this.iterator()\n\t// \t\tlet index = 0\n\t// \t\tlet result\n\t// \t\treturn {\n\t// \t\t\tnext () {\n\t// \t\t\t\tresult = iterator.next()\n\t// \t\t\t\twhile (result.done && index < iterators.length) {\n\t// \t\t\t\t\titerator = getIterator(iterators[index++])()\n\t// \t\t\t\t\tresult = iterator.next()\n\t// \t\t\t\t}\n\t// \t\t\t\treturn result\n\t// \t\t\t}\n\t// \t\t}\n\t// \t})\n\t// }\n\t, forEach (callback) {\n\t\tconst iterator = this.iterator()\n\t\tlet index = -1\n\t\tlet result\n\t\twhile ((result = iterator.next()) && !result.done)\n\t\t\tif (false === callback(result.value, ++index))\n\t\t\t\tbreak\n\t\t//return this\n\t}\n\t//, get length () { return this.toArray().length }\n\t, toArray () { return Array.from(this) }\n\t, toString () { return this.toArray().join('') }\n\t, toObject () { return this.reduce(assignKey, Object.create(null)) }\n\t, toJSON () { return this.valueOf() }\n\t//, [Symbol.iterator] () { return this.iterator() }\n}\n\n// Collection.prototype[Symbol.iterator] = function () { return this.iterator() }\n\nexport function ArrayCollection (array) {\n\tthis.source = array\n\tthis.length = array.length\n}\n\nArrayCollection.prototype = Object.create(Collection.prototype, {\n\tconstructor: { value: ArrayCollection }\n\t, valueOf: { value: Collection.prototype.toArray }\n\t, forEach: { value: function forEach (callback) {\n\t\tlet index = -1\n\t\tconst array = this.source\n\t\tconst length = array.length\n\t\twhile (++index < length)\n\t\t\tif (false === callback(array[index], index))\n\t\t\t\tbreak\n\t\t//return this\n\t} }\n})\n\nexport function StringCollection (string) {\n\tArrayCollection.call(this, string)\n}\n\nStringCollection.prototype = Object.create(ArrayCollection.prototype, {\n\tconstructor: { value: StringCollection }\n\t, valueOf: { value: Collection.prototype.toString }\n})\n\nexport function ObjectCollection (object) {\n\tthis.source = object\n}\n\nObjectCollection.prototype = Object.create(Collection.prototype, {\n\tconstructor: { value: ObjectCollection }\n\t, valueOf: { value: Collection.prototype.toObject }\n\t, forEach: { value: function forEach (callback) {\n\t\tconst object = this.source\n\t\tfor (let key in object)\n\t\t\tif (false === callback(object[key], key))\n\t\t\t\tbreak\n\t\t//return this\n\t} }\n})\n\nfunction ChildCollection (collection) {\n\tthis.parent = collection\n}\n\nChildCollection.prototype = Object.create(Collection.prototype, {\n\tvalueOf: {\n\t\tvalue: function valueOf () {\n\t\t\treturn this.parent.valueOf.call(this)\n\t\t}\n\t}\n})\n\nfunction FilteredCollection (collection, predicate) {\n\t// this.parent = collection\n\tChildCollection.call(this, collection)\n\tthis.predicate = predicate\n}\n\nFilteredCollection.prototype = Object.create(ChildCollection.prototype, {\n\tforEach: { value: function forEach (callback) {\n\t\tconst predicate = this.predicate\n\t\tlet filteredIndex = -1\n\t\treturn this.parent.forEach((value, index) => {\n\t\t\tif (predicate(value, index) && false === callback(value, ++filteredIndex))\n\t\t\t\treturn false\n\t\t})\n\t} }\n})\n\nfunction MappedCollection (collection, mapper) {\n\t// this.parent = collection\n\tChildCollection.call(this, collection)\n\tthis.mapper = mapper\n\tthis.length = collection.length\n}\n\nMappedCollection.prototype = Object.create(ChildCollection.prototype, {\n\tforEach: { value: function forEach (callback) {\n\t\tconst mapper = this.mapper\n\t\treturn this.parent.forEach((value, index) => {\n\t\t\tif (false === callback(mapper(value, index), index))\n\t\t\t\treturn false\n\t\t})\n\t} }\n})\n\nfunction SizedCollection (collection, length) {\n\t// this.parent = collection\n\tChildCollection.call(this, collection)\n\tthis.length = length\n}\n\nSizedCollection.prototype = Object.create(ChildCollection.prototype, {\n\tforEach: { value: function forEach (callback) {\n\t\tconst length = this.length\n\t\treturn this.parent.forEach((value, index) => {\n\t\t\tif (index >= length || false === callback(value, index))\n\t\t\t\treturn false\n\t\t})\n\t} }\n})\n\nfunction getIterator (value) {\n\tif (value == null) // no value\n\t\treturn () => ({ next () { return { done: true } } })\n\tif (typeof value[Symbol.iterator] === 'function') // value has an iterator (ex: array, string, generator)\n\t\treturn () => value[Symbol.iterator]()\n\tif (typeof value.next === 'function') // value implements iterator protocol\n\t\treturn () => value\n}\n\nCollection.from = (value) => {\n\tif (Array.isArray(value))\n\t\treturn new ArrayCollection(value) // collection specialized for array\n\tif (typeof value === 'string')\n\t\treturn new StringCollection(value) // collection specialized for string\n\tif (typeof value === 'object' && typeof value.next !== 'function')\n\t\treturn new ObjectCollection(value) // collection specialized for object\n\treturn new Collection(getIterator(value))\n}\n\nexport default Collection.from\n","import { version } from '../package.json'\nimport assign from 'utils/object/assign'\nimport equals from 'utils/object/_equals'\nimport doc from 'utils/doc'\nimport trace from 'utils/trace'\nimport path from 'utils/path'\nimport map from 'utils/map'\nimport {placeholder} from 'symbols'\nimport partial from 'partial'\nimport curry from 'curry'\nimport compose from 'compose'\nimport arity from 'arity'\nimport not from 'not'\nimport * as functions from 'functions'\n\nimport collection, {filter} from './collection'\n\nexport default assign(\n\t(iterable) => collection(iterable)\n\t, {\n\t\tversion\n\t\t, filter\n\t\t, placeholder\n\t\t, doc\n\t\t, partial, curry, compose, arity, not\n\t}\n\t, functions\n\t, map((fn) => curry.debug(fn), { trace, path, equals, map })\n)\n"],"names":["getProperties","object","const","properties","getPrototype","Array","prototype","push","apply","Object","getOwnPropertyNames","concat","getOwnPropertySymbols","filter","property","indexOf","equals","a","b","aType","is","aProperties","bProperties","aValue","valueOf","bValue","aContainValue","bContainValue","length","every","key","doc","fn","signature","name","toString","call","trace","tag","value","console","log","path","isArray","String","split","reduce","map","iteratee","collection","useMethod","targetFn","mapped","let","hasOwnProperty","context","args","setArity","arity","this","arguments","c","d","e","f","g","h","i","Error","toArray","list","array","getLength","max","placeholder","index","arrayConcat","aLength","bLength","j","partialDebug","applied","partial","target","boundThis","partialArgs","curryFactory","wrapper","parseInt","_curried","debug","curried","composer","slice","composeTrace","compose","composeDebug","composed","last","functions","reduceRight","shift","not","noop","identity","constant","ArrayCollection","ChildCollection","predicate","mapper","getIterator","Symbol","Function","bind","assign","source","getPrototypeOf","curry","curryDebug","in","eq","Collection","result","next","done","constructor","create"],"mappings":"kLKKA,SAASA,GAAeC,GAEvB,IADAC,GAAMC,MACW,MAAVF,EAAgBA,EAASG,EAAaH,GAC5CI,MAAMC,UAAUC,KAAKC,MACpBL,EACAM,OAAOC,oBAAoBT,GAAQU,OAAOF,OAAOG,sBAAsBX,IACrEY,OAAO,SAACC,GAAa,MAAiC,KAAjCX,EAAWY,QAAQD,KAE5C,OAAOX,GAGO,QAASa,GAAQC,EAAGC,GAClChB,GAAMiB,SAAeF,EACrB,IAAIE,UAAiBD,GACpB,OAAO,CACR,IAAIE,EAAGH,EAAGC,GACT,OAAO,CACR,IAAc,WAAVC,EACH,OAAO,CACRjB,IAAMmB,GAAcrB,EAAciB,GAC5BK,EAActB,EAAckB,GAC5BK,EAA8B,kBAAdN,GAAEO,SAA0BP,EAAEO,UAC9CC,EAA8B,kBAAdP,GAAEM,SAA0BN,EAAEM,UAC9CE,EAAgBH,IAAWN,EAC3BU,EAAgBF,IAAWP,CAEjC,OAAOG,GAAYO,SAAWN,EAAYM,QACtCP,EAAYQ,MAAM,SAACC,GAAQ,MAAAd,GAAOC,EAAEa,GAAMZ,EAAEY,QAC3CJ,GAAiBC,EAAgBX,EAAOO,EAAQE,IAAU,GE3BjD,QAASM,GAAKC,GAC5B,MAAO,QAAOA,IAAOA,EAAGC,IAAcD,EAAGE,OAASzB,OAAOH,UAAU6B,SAASC,KAAKJ,ICDnE,QAASK,GAAOC,EAAKC,GAEnC,MADAC,SAAQC,IAAIH,gBAAqBC,GAC1BA,ECNO,QAASG,GAAMA,EAAMzC,GAGnC,MAFII,OAAMsC,QAAQD,KACjBA,EAAOE,OAAOtC,UAAUuC,MAAMT,KAAKM,EAAM,MACnCA,EAAKI,OAAO,SAAC7C,EAAQ6B,GAAQ,MAAU,OAAV7B,EAAiBA,EAAO6B,GAAO7B,GAAQA,GCA7D,QAAS8C,GAAKC,EAAUC,EAAYC,GAClD,mBAD+DD,EAAWF,IAAII,IAAaF,EAAWF,OAASA,GACjF,kBAAnBE,GAAWF,KAAsBG,EAC3C,MAAOD,GAAWF,IAAIC,EAEvB9C,IAAMkD,GAAS,GAAKH,GAAsB,WAC1C,KAAKI,GAAIvB,KAAOmB,GACXK,EAAeL,EAAYnB,KAC9BsB,EAAOtB,GAAOkB,EAASC,EAAWnB,GAAMA,EAAKmB,GAC/C,OAAOG,GCbD,QAAS5C,GAAOwB,EAAIuB,EAASC,GACnC,OAAQA,EAAK5B,QACZ,IAAK,GACJ,MAAOI,GAAGI,KAAKmB,EAChB,KAAK,GACJ,MAAOvB,GAAGI,KAAKmB,EAASC,EAAK,GAC9B,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GACvC,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAChD,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GACzD,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAClE,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAC3E,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GACpF,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAC7F,KAAK,GACJ,MAAOxB,GAAGI,KAAKmB,EAASC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,GACtG,SACC,MAAOxB,GAAGxB,MAAM+C,EAASC,IAIrB,QAASC,GAAUC,EAAO1B,GAEhC,OADA0B,GAAS,IAAMA,EAAQ,GACfA,GACP,IAAK,GACJ,MAAO,YACN,MAAOlD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAgB3C,GACtB,MAAOT,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAiB3C,EAAGC,GAC1B,MAAOV,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAkB3C,EAAGC,EAAG2C,GAC9B,MAAOrD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAqB3C,EAAGC,EAAG2C,EAAGC,GACpC,MAAOtD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAkB3C,EAAGC,EAAG2C,EAAGC,EAAGC,GACpC,MAAOvD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAiB3C,EAAGC,EAAG2C,EAAGC,EAAGC,EAAGC,GACtC,MAAOxD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAoB3C,EAAGC,EAAG2C,EAAGC,EAAGC,EAAGC,EAAGC,GAC5C,MAAOzD,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAmB3C,EAAGC,EAAG2C,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAC9C,MAAO1D,GAAMwB,EAAI2B,KAAMC,WAEzB,KAAK,GACJ,MAAO,UAAmB3C,EAAGC,EAAG2C,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GACjD,MAAO3D,GAAMwB,EAAI2B,KAAMC,WAEzB,SACC,KAAMQ,OAAM,UAAUV,yBAIlB,QAASW,GAASC,EAAM1C,kBAAS0C,EAAK1C,OAG5C,KAFA1B,GAAMqE,GAAQlE,MAAMuB,GAEbA,KACN2C,EAAM3C,GAAU0C,EAAK1C,EAEtB,OAAO2C,GAGD,QAASC,GAAWF,EAAMG,EAAKC,GACrCrB,GAAIzB,GAAS,EACT+C,EAAQL,EAAK1C,MAGjB,KAFA+C,EAAQF,IAAQE,EAAQF,GAEjBE,KACNL,EAAKK,KAAWD,GAAe9C,GAEhC,OAAOA,GAGD,QAASgD,GAAa3D,EAAGC,EAAGwD,GAKlC,IAAKrB,GAJCwB,GAAU5D,EAAEW,OACZkD,EAAU5D,EAAEU,OACZ2C,EAAQlE,QAEL8D,EAAI,EAAGY,EAAI,EAAOF,EAAJV,GAAmBW,EAAJC,EAAaZ,IAClDI,EAAMJ,GAAKA,GAAKU,GAAW5D,EAAEkD,KAAOO,EAAcxD,EAAE6D,KAAO9D,EAAEkD,EAE9D,OAAOI,GC9FD,QAASS,GAAchD,EAAIwB,qBACjCtD,IAAM+E,GAAUC,EAAQlD,EAAIwB,GAGtB2B,EAASnD,EAAGmB,IAAanB,CAO/B,OANAiD,GAAQ9C,SAAW,WAAM,MAAA,0BAA0BgD,GACnDF,EAAQhD,GAAakD,EAAOlD,GAC5BgD,EAAQ9B,GAAYgC,EACpBF,EAAQG,GAAazB,KACrBsB,EAAQI,GAAe7B,EAEhByB,EAGO,QAASC,GAASlD,EAAIwB,qBACpCtD,IAAM0B,GAASI,EAAGJ,MAElB,OAAO6B,GAAS7B,EAAS4C,EAAUhB,EAAM5B,EAAQ8C,GAAc,WAC9D,MAAOlE,GAAMwB,EAAI2B,KAAMiB,EAAYpB,EAAMI,UAAWc,MCdtD,QAASY,GAAcJ,EAASK,GAC/B,MAAO,UAAgBvD,EAAI0B,kBAAQ1B,EAAGJ,QACrC8B,EAAQ8B,SAAS9B,EAAO,KAAO,CAE/BxD,IAAMuF,GAAWhC,EAASC,EAAO,WAChC,MAAOc,GAAUZ,UAAWF,EAAOgB,KAAiBhB,EACnDlD,EAAMwB,EAAI2B,KAAMC,WAChBsB,EAAQ9C,KAAKuB,KAAM8B,EAAU7B,YAG/B,OAAO2B,GAAUA,EAAQE,EAAUzD,GAAMyD,GAI3C,QAASC,GAAOC,EAAS3D,GAExB9B,GAAMiF,GAASnD,EAAGmB,IAAanB,CAK/B,OAJA2D,GAAQxD,SAAW,WAAM,MAAA,gBAAgBgD,GACzCQ,EAAQ1D,GAAakD,EAAOlD,GAC5B0D,EAAQxC,GAAYgC,EAEbQ,ECtBR,QAASC,GAAUpC,EAAMxB,GACxB,MAAO4C,IACLpE,EAAMwB,EAAI2B,KAAMU,EAAQb,EAAMxB,EAAGJ,QAAU4B,EAAK5B,aAC9CiE,MAAMzD,KAAKoB,EAAMxB,EAAGJ,QAAU,IAI5B,QAASkE,KACf,MAAOtF,GAAMuF,EAASpC,KAAMZ,EAAI,SAACf,GAAO,MAAAK,GAAM,UAAWL,IAAK4B,YAGxD,QAASoC,KACf9F,GAAM+F,GAAWzF,EAAMuF,EAAS,KAAMnC,WAChCsC,EAAOtC,UAAUA,UAAUhC,OAAS,GAGpCuD,EAASe,EAAK/C,IAAa+C,CAKjC,OAJAD,GAAS9D,SAAW,WAAM,MAAA,iBAAiBgD,GAC3Cc,EAAShE,GAAakD,EAAOlD,GAC7BgE,EAAS9C,GAAYgC,EAEdc,EAGO,QAASF,KACvB7F,GAAMiG,GAAY9B,EAAQT,WACpBsC,EAAOtC,UAAUA,UAAUhC,OAAS,EAE1C,OAAO6B,GAASyC,GAAQA,EAAKtE,QAAU,EAAG,WACzC,MAAOuE,GAAUC,YAAYR,EAAUhC,WAAWyC,UCpCrC,QAAS3C,GAAO1B,EAAI0B,GAClC,sBAD0C1B,EAAGJ,QACtC6B,EAASC,EAAO,WAEtB,MADAE,WAAUhC,OAAS8B,EACZlD,EAAMwB,EAAI2B,KAAMC,aCHV,QAAS0C,GAAKtE,GAC5B,MAAOyB,GAASzB,EAAGJ,OAAQ,WAC1B,OAAQpB,EAAMwB,EAAI2B,KAAMC,aCHX,QAAS2C,MCAT,QAASC,GAAUjE,GACjC,MAAOA,GCDO,QAASkE,GAAUlE,GACjC,MAAO,YAAM,MAAAA,IEcdrC,wEAkFqB0B,qBAkBpB8E,mDAwBQC,kBACM1D,EAWf,uBAEwBU,aAClBiD,4BAgBLD,EAAgBvE,UAAWa,QACpB4D,OAASA,uBAcjB,qDAgBSC,MACR,yFAEiBC,oGAGYxE,2BpBjNfyE,SAAS5E,KAAK6E,KAAKxG,OAAOH,UAAUgD,kBCEpC7C,OAAOyG,QAAU,SAAiB/B,GAChD,IAAK9B,gBAAIsB,EAAQ,EAAGA,EAAQf,EAAUhC,OAAQ+C,IAAS,CACtDtB,GAAI8D,GAASvD,EAAUe,EACvB,IAAc,MAAVwC,EACH,IAAK9D,GAAIvB,KAAOqF,GACX7D,EAAe6D,EAAQrF,KAC1BqD,EAAOrD,GAAOqF,EAAOrF,IAEzB,MAAOqD,MCVO1E,OAAOW,IAAM,SAAaH,EAAGC,GAC3C,MAAOD,KAAMC,EAEN,IAAND,GAAW,EAAIA,IAAM,EAAIC,EAEzBD,IAAMA,GAAKC,IAAMA,KCLJT,OAAO2G,eEFTnF,EAAY8E,OAAO,aACnB5D,EAAW4D,OAAO,YAClB3B,EAAY2B,OAAO,aACnB1B,EAAc0B,OAAO,eACrBrC,EAAcqC,OAAO,cCFlChF,GAAIE,GAAa,0BCAjBI,EAAMJ,GAAa,0BECnBc,EAAId,GAAa,4EEAjBiD,EAAQjD,GAAa+C,EAAa/C,GAAa,0DAE/CiD,EAAQR,YAAcM,EAAaN,YAAcA,EAEjDQ,EAAQQ,MAAQV,CCHhB9E,IAAMmH,GAAQ/B,EAAaJ,GACrBoC,EAAahC,EAAaN,EAAcU,EAE9C2B,GAAMpF,GAAaqF,EAAWrF,GAAa,uEAE3CoF,EAAM3C,YAAc4C,EAAW5C,YAAcA,EAE7C2C,EAAM3B,MAAQ4B,ECNdvB,EAAQ9D,GAAa+D,EAAa/D,GAAa6D,EAAa7D,GAC5D,wDAEA8D,EAAQL,MAAQM,EAEhBD,EAAQ1D,MAAQyD,ECPhBpC,EAAMzB,GAAa,qECAnBqE,EAAIrE,GAAa,oDCDjBsE,EAAKtE,GAAa,wBCAlBuE,EAASvE,GAAa,oBCAtBwE,EAASxE,GAAa,uBEFf/B,IAAMiG,kBACZI,gBACUC,WACAC,gBAIA,SAACvF,GAAM,MAAA,UAACD,GAAM,MAAA2B,yCACtB2E,KAAQ,SAACrG,GAAM,MAAA,UAACD,GAAM,MAAA2B,yCACtB4E,GAAQ,SAACtG,GAAM,MAAA,UAACD,GAAM,MAAAA,SACtBqF,IAAQ,SAACpF,GAAM,MAAA,0IAGUA,2NAeduG,uEAMZpE,aAAYxC,uEAGZ,0CAGA,GAAI8D,GAAQ,kDAELf,+EAIPD,oEAQO,oTA8BC+D,IAAAC,YAAmBC,2RAqBbrF,SACbf,iBAA6BlB,wJAiB/BuH,+DAQgBvH,iBAAmBwH,OAAOL,mGAIzC,2CAEwBxH,wEAYjB,uHAcP,kLAkBA,wEAEwB4G,4FAcxB,uHAkBD,0HCrMcC,UAGX7D,UAEA0B,EAAGuC"}