#!/usr/bin/env node

var bundler = require('rollup')
var transpiler = require('rollup-plugin-babel')
var npm = require('rollup-plugin-npm')
var commonjs = require('rollup-plugin-commonjs')

function build (entry, dest, format, moduleName) {
	return bundler
		.rollup({
			entry: entry
			, plugins: [
				{
					resolveId: function (importee) {
						var relative = importee && applyPaths(paths, importee)
						//console.log(paths, importee, relative, relative && path.resolve(relative))
						return relative && path.resolve(relative)
					}
				},
				transpiler(),
				// npm({ jsnext: true, main: true }),
				// commonjs()
			]
		})
		.then(function (bundle) {
			return bundle
				.write({
					dest: dest,
					format: format,
					moduleName: moduleName
				})
		})
}

var project = require('./package')

function bundle (format, moduleName) {
	return build(project['jsnext:main'], project.main, format || 'umd', moduleName || project.name)
		.then(function () { console.log('bundle ready - %s', project.main) })
		.catch(console.trace.bind(console))
}

var path = require('path')

var paths = project['jsnext:paths']
// hard copy of https://github.com/ModuleLoader/es6-module-loader/blob/70348ebed569345df5ac75ac000d1c9410042b2b/src/system.js#L21
function applyPaths(paths, name) {
  // most specific (most number of slashes in path) match wins
  var pathMatch = '', wildcard, maxWildcardPrefixLen = 0;

  // check to see if we have a paths entry
  for (var p in paths) {
    var pathParts = p.split('*');
    if (pathParts.length > 2)
      throw new TypeError('Only one wildcard in a path is permitted');

    // exact path match
    if (pathParts.length == 1) {
      if (name == p)
        return paths[p];
      
      // support trailing / in paths rules
      else if (name.substr(0, p.length - 1) == p.substr(0, p.length - 1) && (name.length < p.length || name[p.length - 1] == p[p.length - 1]) && paths[p][paths[p].length - 1] == '/')
        return paths[p].substr(0, paths[p].length - 1) + (name.length > p.length ? '/' + name.substr(p.length) : '');
    }
    // wildcard path match
    else {
      var wildcardPrefixLen = pathParts[0].length;
      if (wildcardPrefixLen >= maxWildcardPrefixLen &&
          name.substr(0, pathParts[0].length) == pathParts[0] &&
          name.substr(name.length - pathParts[1].length) == pathParts[1]) {
            maxWildcardPrefixLen = wildcardPrefixLen;
            pathMatch = p;
            wildcard = name.substr(pathParts[0].length, name.length - pathParts[1].length - pathParts[0].length);
          }
    }
  }

  var outPath = paths[pathMatch];
  if (typeof wildcard == 'string')
    outPath = outPath.replace('*', wildcard);

  return outPath;
}

var watcher = require('chokidar')
var dir = path.dirname(project['jsnext:main'])

console.log('watching "%s" dir', dir)

watcher
	.watch(dir, { ignored: /[\/\\]\./ })
	.on('change', function (path) {
		console.log('"%s" file updated', path)
		bundle()
	})

bundle()
